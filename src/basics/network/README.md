# 一.  网络基础概念

## 1 OSI开放系统互联模型：
### 1.1 此模型7层

> 物理层 -> 数据链路层 -> 网络层 -> 传输层 -> 会话层 -> 表示层 -> 应用层

### 1.2 各层做的工作及对应的常见协议

> 应用层： （Telnet、E-mail、FTP，HTTP）
>
> 表示层：数据格式定义、数据转换/加密
>
> 会话层: 建立通信进程的逻辑名字与物理名字之间的关系。
>
> 传输层：差错处理/恢复、流量控制、提供可靠的数据传输 (TCP/UDP)
>
> 网络层：数据分组、 路由选择	(IP、ICMP、IGMP)
>
> 数据链路层: 数据组成可发送、可接收的帧
>
> 物理层： 传输物理信号、接口、信号形式、速率等

## 2 TCP/IP协议族的体系结构

因为实际生产过程中，由于OSI开放系统互联模型太过繁琐，所以没人使用，后面提出的其他体系结构，都是基于OSI开放系统互联模型而来的。

### 2.1 此模型4层

> 网络接口和物理层 -> 网络层 -> 传输层 -> 应用层

### 2.2  各层做的工作及对应的常见协议

> 应用层：
>
> ​			HTTP(Hypertext Transfer Protocol)   超文本传输协议, 万维网的数据通信的基础
>
> ​			FTP(File Transfer Protocol)  文件传输协议， 是用于在网络上进行文件传输的一套标准协议，使用TCP传输
>
> ​			TFTP(Trivial File Transfer Protocol)   简单文件传输协议，是用于在网络上进行文件传输的一套标准协议，使用UDP传输
>
> ​			SMTP(Simple Mail Transfer Protocol)  简单邮件传输协议， 一种提供可靠且有效的电子邮件传输的协议



> 传输层：
>
> TCP(Transport Control Protocol)  传输控制协议， 是一种**面向连接的、可靠的**、基于字节流的传输层通信协议
>
> UDP(User Datagram Protocol)  用户数据报协议， 是一种**无连接、不可靠**、快速传输的传输层通信协议



> 网络层：
>
> IP(Internetworking Protocol)   网际互连协议， 是指能够在多个不同网络间实现信息传输的协议
>
> ICMP(Internet Control Message Protocol)   互联网控制信息协议， 用于在IP主机、路由器之间传递控制消息 ----ping 命令使用的协议
>
> IGMP(Internet Group Management Protocol)   互联网组管理， 是一个组播协议，用于主机和组播路由器之间通信



> 数据链路层：
>
> ARP(Address Resolution Protocol)  地址解析协议， 通过IP地址获取对方mac地址
>
> RARP(Reverse Address Resolution Protocol)  逆向地址解析协议， 通过mac地址获取ip地址

### 2.3 数据封包和拆包的过程:
<pre>

> ​								张三（发送封包的过程）														                        李四（接受端数据解包过程)

应用层							                hello（数据）																						  hello（数据）

​											&darr;																								        &uarr;

传输层					                TCP头 + hello（TCP段）																			        ~~TCP头~~ + hello（TCP段）

​											&darr;																									    &uarr;

网络层	 			                IP头 + TCP头 + hello（IP数据报）																	  	    ~~IP头~~  + TCP头 + hello（IP数据报）

​											&darr;																									    &uarr;

链路层			            以太网头 +  IP 头 + TCP头 + hello  (以太网数据帧)					&rarr;				                    ~~以太网头~~ + IP头 + TCP头 + hello（令牌环网数据帧）

​					                                                    （路由器接受以太网数据帧并根据目标IP地址转发到令牌环网接口）
</pre>

## 3.  TCP 和 UDP 异同

**相同点**:

​				都是传输层协议

**不同点**:

<pre>
<b>TCP（即传输控制协议）概念</b>：
	是一种面向连接的传输层协议，它能提供高可靠性通信(即数据无误、数据无丢失、数据无失序、数据无重复到达的通信。
适用情况：
	适合于对传输质量要求较高，以及传输大量数据的通信。在需要可靠数据传输的场合，通常使用TCP协议MSN/QQ等即时通讯软件的用户登录账户管理相关的功能，通常采用TCP协议<br>
<b>UDP（User Datagram Protocol）用户数据报协议</b>:
	是不可靠的无连接的协议。在数据发送前，因为不需要进行连接，所以可以进行高效率的数据传输。
适用情况：
	发送小尺寸数据（如对DNS服务器进行IP地址查询时）,在接收到数据，给出应答较困难的网络中使用UDP。（如：无线网络）,适合于广播/组播式通信中。MSN/QQ/Skype等即时通讯软件的点对点文本通讯以及音视频通讯通常采用UDP协议
流媒体、VOD、VoIP、IPTV等网络多媒体服务中通常采用UDP方式进行实时数据传输
</pre>

## 4.  字节序

<pre>
1. 不同类型CPU的主机中，内存存储多字节数据的字节顺序，称为主机字节序(HBO)。
2. 其中这种字节数据顺序又分为两种类型:
	<b>小端序（little-endian）</b> - 低序字节存储在低地址
将数据低字节存储在首地址，称为“Little-Endian”字节序，Intel、AMD等采用的是这种方式；
	<b>大端序（big-endian）</b>    - 高序字节存储.在低地址
将数据高字节存储在首地址，称为“Big-Endian”字节序，由ARM、Motorola等所采用
</pre>

## 5. socket与套接字

<pre>
socket本来也是用于本地进程间通信的，后来有了TCP/IP协议族的加入，才能实现跨主机通信。
socket是一个函数，我们可以指定参数告诉内核封装什么样的协议
socket是一种特殊的文件描述符 (everything in Unix is a file), 并不仅限于TCP/IP协议，其他体系结构也会用到 socket
套接字分为：
		流式套接字(SOCK_STREAM)TCP:
               提供了一个面向连接、可靠的数据传输服务，数据无差
               错、无重复的发送且按发送顺序接收。内设置流量控制，
               避免数据流淹没慢的接收方。数据被看作是字节流，
               无长度限制。
		数据报套接字(SOCK_DGRAM)UDP
	           提供无连接服务。数据包以独立数据包的形式被发送，
	           不提供无差错保证，数据可能丢失或重复，顺序发送，
	           可能乱序接收。
	    原始套接字(SOCK_RAW):
	    	   可以对较低层次协议如IP、ICMP直接访问。
</pre>

## 6.  IP地址
### 6.1 IP地址和Mac地址区别

<pre>
IP地址是主机在网络中的编号，这个编号就是IP地址。
IP地址和MAC地址区别：
            每张网卡在出厂时都会有一个唯一的标识，叫做MAC地址。
            在局域网内部通信，都是使用MAC地址通信的。交换机是工作在链路层的设备
            如果数据想要走出局域网，就要使用IP地址了。路由器是工作在网络层的设备
</pre>

### 6.2 IPV4和IPV6的区别

<pre>
<b>IP地址分为  IPV4 和 IPV6</b>
            IPV4  4字节（32bit）
            IPV6  16字节 (128bit)
<b>为什么有IPV4和IPV6之分?</b>
          	   是因为IPV4地址不够用了。IPV4地址不够用了，不一定必须使用IPV6，因为现在有很多技术，都可以弥补IPV4数量不足的缺陷，如 NAT 技术：任意一个IP地址都可以经过路由器下发局域网IP地址，局域网内部通信，使用局域网的IP地址，如果数据要走出局域网会通过NAT技术，将数据包中的源IP地址从局域网IP替换成公网IP。
               通过百度查询 到的 IP地址，是我们付费在运营商那里租用过来的。
               通过我们自己的路由器，可以下发多个局域网IP地址，也就是我们ifconfig查询到的ip地址。
</pre>
### 6.3 IP地址的表达形式

<pre>
    192.168.70.10   叫做点分十进制，是方便我们人类看的，是一个字符串类型。而在计算中，ip地址就是一个无符号的4字节整型
</pre>

### 6.4 IP地址的分类
<pre>
类 A 地址：
    范围：1.0.0.0 到 127.255.255.255
    第一个字节范围：1-127
    特点：用于较大规模的网络，可提供大约1677万个主机地址。(多用于政府/大公司、学校)<br>
类 B 地址：
    范围：128.0.0.0 到 191.255.255.255
    第一个字节范围：128-191
    特点：适用于中等规模的网络，可提供约6.5万个主机地址。（中等规模的公司）<br>
类 C 地址：
    范围：192.0.0.0 到 223.255.255.255
    第一个字节范围：192-223
    特点：用于较小规模的网络，提供约254个主机地址。（个人）<br>
类 D 地址：
    范围：224.0.0.0 到 239.255.255.255
    第一个字节范围：224-239
    特点：用于多播（Multicast）通信，不用于标识单个主机，而是用于将数据包传送到多个目的主机。（组播）<br>
类 E 地址：
    范围：240.0.0.0 到 255.255.255.255
    第一个字节范围：240-255
    特点：保留地址，未分配使用，用于将来可能的用途。
</pre>
<pre>
<b>其中每个IP地址又可以通过路由器，下发局域网IP地址,每类IP地址都有专门划分子网的保留段。</b>
<table>
    <tr> <!-- 表格的行 -->
        <th style="width: 100px">类型</th>
        <th>私有IP地址范围</th>
    </tr>
    <tr>
        <td>A类</td>
        <td>10.0.0.1 ~ 10.225.225.254</td>
    </tr>
     <tr>
        <td>B类</td>
        <td>172.16.0.1 ~ 172.31.255.254</td>
    </tr>
     <tr>
        <td>C类</td>
        <td>192.168.0.1 ~ 192.168.255.254</td>
    </tr>
</table>
</pre>

## 7. 子网掩码

<pre>
    是由一堆连续的1和连续的0组成的。用来和IP地址取与运算来获取网络号的。从而能限制某一网段内能容纳的最大主机数。如，ip地址是192.168.70.8 子网掩码设置成 255.255.255.0 取与运算可以得到的结果：192.168.70.0  ----这是网络号，网络号相同时，才能进行通信。这是，该网段内共有IP地址 256 个：
				其中 192.168.70.0 是网络号，是不能占用的
				192.168.70.255 是广播的地址，也不能占用
	网关设备也需要占用一个IP地址，一般是同一局域网内可用的编号最小的。192.168.70.1，所以能容纳的主机数：256 - 1 - 1 - 1(网关设备也可以算作一台IP主机) = 254
</pre>

## 8. 端口号
<pre>
    虽然在linux系统中，进程号是用来标识唯一进程的，但是由于进程号是有操作系统分配的
且进程停止再运行时，不能保证进程号不变，所以使用进程号来标识进程就可能出现问题。
所以就发明了端口号来标识进程，端口号是人为可以自己指定的，
为了区分一台主机接收到的数据包应该转交给哪个进程来进行处理，使用端口号来区别
端口号一般由IANA (Internet Assigned Numbers Authority) 管理
    众所周知端口：1~1023（1~255之间为众所周知端口，256~1023端口通常由UNIX系统占用, 已登记端口：1024~49151, 动态或私有端口：49152~65535
</pre>

## 9. 网络编程模型
<pre>
    C/S模型： 客户端 服务器模型
    B/S模型： 浏览器 服务器模型
</pre>

## 10. 客户端与服务端通信
### 10.1 流程
<pre>
            服务器端                            客户端

            socket()                            socket()
             &darr;                                  &darr;
             bind()                              bind()
             &darr;                                  &darr;
             listen()                            connect()
             &darr;                                  &darr;
             accept()                            send()/recv()
             &darr;                                  &datt;
             send()/recv()                       close()
             &darr;
             close()
</pre>
<b>服务器</b>：
>        创建流式套接字--socket()       填充服务器的网络信息结构体
>        将套接字和服务器的网络信息结构体绑定--bind()
>        将套接字设置成被动监听状态--listen()
>        阻塞等待客户端连接--accept()
>        数据收发--read  write
>        关闭套接字--close()



<b>客户端</b>：
>        创建流式套接字--socket()
>        填充服务器的网络信息结构体
>        与服务器建立连接--connect()
>        数据收发--read  write
>        关闭套接字--close()
>


### 10.2 注意事项
<pre>
        当两台主机,主机A（服务端）  和 主机B（客户端） 进行通信时, 主机A需要将通讯端口(例如：8080)打开。否则防火墙不允许外部主机访问8080端口。
        通过 `sudo ufw allow 端口号` 打开端口。 （确保防火墙是打开状态, 可通过此命令查看 `sudo ufw status`）
</pre>
